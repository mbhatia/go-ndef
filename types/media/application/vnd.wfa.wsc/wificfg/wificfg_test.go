/***
    Copyright (c) 2016, Hector Sanjuan

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
***/

package wificfg

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"testing"
)

var testPayload = &Payload{
	Credentials: []*Credential{
		&Credential{
			SSID:                     "ssid",
			AuthenticationType:       AuthWPAWPA2Personal,
			EncryptionType:           EncAESTKIP,
			NetworkKey:               "password",
			MACAddress:               [6]byte{0, 23, 42, 58, 13, 12},
			KeyProvidedAutomatically: true,
			Enabled802_1X:            true,
			NetworkKeyShareable:      true,
			EAPType:                  []byte("type1"),
			EAPIdentity:              "eapidentity",
			ExtraAttrs: []*TLV{
				&TLV{
					T: tVendorExtension,
					L: 1,
					V: []byte{0xCD},
				},
			},
		},
	},
	RFBand:     RF5_0Ghz,
	APChannel:  5,
	MACAddress: [6]byte{2, 3, 3, 4, 5, 6},
	Version2:   0x20,
	ExtraAttrs: []*TLV{
		&TLV{
			T: tVendorExtension,
			L: 1,
			V: []byte{0xAB},
		},
	},
}

func TestNew(t *testing.T) {
	pl := New("myssid", "mypw", AuthWPA2Personal, EncAES)
	cred := pl.Credentials[0]
	if cred.SSID != "myssid" ||
		cred.NetworkKey != "mypw" ||
		cred.AuthenticationType != AuthWPA2Personal ||
		!bytes.Equal(cred.MACAddress[:], []byte{0, 0, 0, 0, 0, 0}) ||
		cred.EAPIdentity != "" {
		t.Error("Simple credential not correctly generated by New()")
	}
	if pl.Version2 != 0x20 ||
		pl.RFBand != 0 ||
		pl.APChannel != 0 {
		t.Error("Simple playload not correctly generated by New()")
	}
}

func TestString(t *testing.T) {
	t.Log(testPayload.Type() + ":" + testPayload.String())
	str := ""
	for _, t := range []byte{0, RF2_4Ghz, RF5_0Ghz, RF60Ghz, 99} {
		str += fmt.Sprintf("%d-%s ", t, _RFBandString(t))
	}
	t.Logf("Available RFBands: %s\n", str)

	str = ""
	for _, t := range []uint16{EncNone, EncWEP, EncTKIP, EncAES, EncAESTKIP, 99} {
		str += fmt.Sprintf("%d-%s ", t, _EncTypeString(t))
	}
	t.Logf("Available Encryption types: %s\n", str)

	str = ""
	for _, t := range []uint16{AuthOpen, AuthWPAPersonal, AuthShared, AuthWPAEnterprise, AuthWPA2Enterprise, AuthWPA2Personal, AuthWPAWPA2Personal, 99} {
		str += fmt.Sprintf("%d-%s ", t, _AuthTypeString(t))
	}
	t.Logf("Available Auth types: %s\n", str)
}

func TestMarshal(t *testing.T) {
	byts := testPayload.Marshal()
	parsedPl := new(Payload)
	parsedPl.Unmarshal(byts)
	rebytes := parsedPl.Marshal()
	if !bytes.Equal(byts, rebytes) {
		t.Logf("Expected: % 02x\n", byts[76:])
		t.Logf("Got     : % 02x\n", rebytes[76:])
		t.Error("Marshal/Unmarshal/Marshal did not generate the same bytes")
	}
}

func TestUnmarshal(t *testing.T) {
	byts, err := ioutil.ReadFile("fixtures/wificfg.raw")
	if err != nil {
		t.Fatal("Error reading fixture")
	}
	pl := new(Payload)
	pl.Unmarshal(byts)
	t.Log(pl)
	cred := pl.Credentials[0]
	if cred.SSID != "ssid" {
		t.Error("Bad parsed SSID")
	}
	if cred.AuthenticationType != AuthWPA2Personal {
		t.Error("Bad parsed auth")
	}
	if cred.EncryptionType != EncTKIP {
		t.Error("Bad parsed encryption")
	}
	if cred.NetworkKey != "pass" {
		t.Error("Bad parsed network key")
	}
}

func TestLen(t *testing.T) {
	byts, err := ioutil.ReadFile("fixtures/wificfg.raw")
	if err != nil {
		t.Fatal("Error reading fixture")
	}
	expLen := len(byts)
	pl := new(Payload)
	pl.Unmarshal(byts)
	if expLen != pl.Len() {
		t.Error("Unexpected result from Len()")
	}
}
